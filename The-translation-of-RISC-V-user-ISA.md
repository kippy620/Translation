# RISC-V 指令集指南
## 卷Ⅰ:用户级 ISA
## 版本2.0

Andrew Waterman, Yunsup Lee, David Patterson, Krste Asanovi´c
CS Division, EECS Department, University of California, Berkeley
{waterman|yunsup|pattrsn|krste}@eecs.berkeley.edu

2014年5月6日

这个文档也被作为技术报告（ UCB/EECS-2014-54）。

## 第一章

### 1.1 RISC-V ISA 概述

RISC-V ISA 是由一个（任何微体系结构都必须能实现的）基本的整型 ISA，加上一些可选的基本 ISA 的拓展集构成的。这个基本 ISA 和早期 RISC 处理器的基本 ISA 非常相似，除了没有分支延迟槽以及支持可选的变长的指令编码格式。这个基本的 ISA 受限于一个最小的指令集，这个指令集足够用来给编译器，汇编器，链接器，以及（有额外管理员级的操作的）操作系统提供一个合理的目标，同样也提供一个实用的ISA以及软件工具链“skeleton”，有了这些，更多的定制处理器 ISAs 能够被构建。

每一个基本整型指令集以整型寄存器的宽度以及用户地址空间相应的尺寸为特点。这有两种基本的整型变体 RV32I 和 RV64I ，分别被描述在第 2 章和第 3 章，各自提供 32-bit 或者 64-bit 的用户级地址空间。硬件实现和操作系统可能只给用户程序提供 RV32I 和 RV64I 其中一种，也可能两种都提供。第 17 章描述基本整型指令集的一个未来变体 RV128I，支持一个二维的（flag） 128-bit 的用户地址空间。

> 尽管 64-bit 的地址空间对于更大的系统来说是一个必要条件，但是我们相信 32-bit 的地址空间在接下来的数十年对于许多嵌入式的和客户端的设备依然是足够的，并且对于更低的访存流量和能量损耗将是有益的。另外，32-bit 的地址空间针对教学目的来说是足够的。一个更大的二维的（flag）128-bit 的用户地址空间可能最终会被需要，所以我们要确保它在 RISC-V ISA 框架中能够被安置。

基本整型 ISA 可能是一个硬件实现的子集，但是一个管理员层次的操作码自陷以及软件仿真必须被用来实现（硬件不提供的）功能性。

> 基本整型 ISA 的子集可能对于教学目的是有用的，但是基本整型 ISA 已经被定义成这样以致没有什么动力去子集一个（超出省略对未对齐地址的存储器访问的支持以及把所有 SYSTEM 指令看做一个单一的自陷范围的）真正的硬件实现。

RISC-V 已经被设计去支持大量的定制和专用。基本整型 ISA 能够被一个或多个可选的指令集拓展集扩展，但是基本整型指令不能够被重新定义。我们把 RISC-V 指令集拓展分为标准和非标准两种拓展。标准拓展通常应该是有用的，并且应该不会和其他标准拓展冲突。非标准拓展可能是高度专用的，或者可能和其他标准或者非标准的拓展产生冲突。指令集拓展可能根据基本整型指令集的宽度提供稍稍不同的功能。第 9 章描述拓展 RISC-V ISA 的不同方式。我们也已经为 RISC-V 基本指令和指令集拓展指定了一个命名规则，这被详细地描述在第 10 章。

为了支持更多的通用软件开发，一组标准拓展被定义去支持整型乘法、除法，原子操作，以及单双精度的浮点算术。基本整型 ISA 被命名为 "I",包括整型计算指令，整型取数，整型存数，以及控制流指令，它对于所有 RISC-V 实现是强制的。标准整型乘法和除法拓展被命名为 "M"，增加了乘法和除法的指令，并把结果保存到整型寄存器。标准原子指令拓展，用 "A" 来表示，为处理器间同步，增加了原子地读，修改，以及写存储器的指令。标准的单精度浮点拓展，用 "F" 来表示，增加了浮点寄存器，单精度计算指令，以及单精度的取数和存数指令。标准的双精度浮点拓展，用 "D" 来表示，扩展了浮点寄存器，并且增加了双精度计算指令，以及双精度的取数和存数指令。一个整型基本指令集加上四个标准拓展集（"IMAFD"）被赋予缩写 "G"，并且提供一个通用的标量的指令集。RV32G 和 RV64G 是当前编译工具链默认的目标。后面的章节会描述这些以及其他计划有的标准 RISC-V 拓展。

除了基本整型 ISA 和标准拓展之外的一条新的指令尽管可能对于某一特定领域是很有益的，但是很少能够给所有的应用都提供一个重要的好处。当能源效率问题迫使更多的专用化时，我们相信简化一个 ISA 专用需要的部分是很重要的。然而其他体系结构通常把他们的 ISA 看做一个单独的实体，随着时间过去，当指令被添加的时候，他们的 ISA 变成一个新的版本，而 RISC-V 尽力随着时间过去仍保持基本 指令集和每个标准拓展不变，并且把新的指令作为更深一层的可选拓展。例如，基本整型 ISAs 将会继续作为完全地被支持的单独的 ISAs，不管任何一个随后的拓展。

> 随着用户 ISA 规格 2.0 版本的发布，对于未来的发展，我们决定将 "IMAFD" 基本指令集和标准的拓展（亦称作 "G"）保持不变。

### 1.2 指令长度编码

基本 RISC-V ISA 是定长的 32-bit 的指令，自然地必须在 32-bit 边界对齐。可是，标准的 RISC-V 编码方案被设计来支持变长指令的 ISA 拓展（每条指令在长度上可以是任何数量个 16-bit 指令包，并且包自然地在 16-bit 的边界上对齐）。第 13 章描述的标准的压缩 ISA 拓展通过提供压缩的 16-bit 的指令来减少代码尺寸，放宽对齐的约束条件来允许所有的指令（16-bit 和 32-bit）能够在任意 16-bit 的边界上对齐来提高代码密度。

图 1.1 阐明了标准 RISC-V 指令长度的编码约定。在基本 ISA 中，所有 32-bit 的指令的最低两位都被设置成 11。可选的
16-bit 的压缩指令集拓展的最低两位都被设置成 00，01，或者 10。编码超过 32 位的标准指令集拓展有额外的低序位被设置为1，被展示在图 1.1 中的 48-bit 和 64-bit 长度的指令就遵循这个约定。指令长度在 80 位和 304 位之间的指令被编码使用一个 4-bit 的字段来给出除了前 5×16 位字以外的 16-bit 字的数量。用 11 或者更多低位的操作码位设置为 1 的编码格式会为未来更长的指令编码保留。

> 给定代码尺寸以及一种压缩格式的节能，我们想要去构建对一种压缩格式支持的 ISA 编码方案，而不是作为一种事后想法增加它，但是未来允许更简单的实现，我们不想把压缩格式弄成强制的。我们也想可选地允许更长的指令去支持实验和大规模的指令集拓展。虽然我们的编码约定需要一个更紧致的核心 RISC-V ISA 的编码，但是这有很多有益的影响。
一个标准 G ISA 的实现只需要保存最高 30 位的有效位在指令缓冲器（节省了6.25%的空间）。当指令缓冲器再填满的时候，任何的指令（低位被清除）在存储到缓存器中之前都应该被重新编码成合法的 30-bit 的指令来防止非法的指令自陷行为。
    或许更重要的是通过压缩我们的基本 ISA 成一个 32-bit 指令字的子集，我们可以预留更多可获得的空间给定制的拓展。特别是基本的 RV32I ISA 在 32-bit 的指令字中使用少于 1/8 的编码空间。和在第 9 章中描述的一样，一个保留对大于等于 32-bit 的标准指令集拓展的支持，但是不需要支持标准压缩指令拓展的实现可以映射 3 个额外的 30-bit 的指令空间到 32-bit 定长的指令编码格式中。进一步来说，假如这个实现也不需要长度大于 32-bit 的指令的话，那么它能够保留更多的四个主要的操作码。

> 我们把它（任何长度的全零指令都是不合法的，因为这会迅速地造成错误的跳转到零位存储器区域）看做一个特点。

虽然基本 RISC-V ISA 有一个小头优先的存储器系统，但是不标准的变体可以提供一个大头优先或者双端存储器系统。指令根据实现的物理字节顺序被存储在存储器中，并且每 16-bit 的包被存储在一个存储器半字中。包含一个指令的包被存储在增加的半字地址中，最低地址的包保存在指令规范中的最低位，例如，指令总是以一个小头优先的包顺序存储，不管存储器系统的字节顺序。在图 1.2 中的代码序列将正确地存储一个 32-bit 的指令到存储器中，不管存储器系统的字节顺序。

> 我们给 RISC-V 的存储器系统选择小头优先的字节顺序，是因为小头优先的系统目前在商业上是占有优势的（所有 x86 系统；针对 ARM 的 iOS, Android,和 Windows）。一个次要的原因是我们也已经发现小头优先的存储器系统对于硬件设计师来说是更自然的。可是，例如 IP 网络等特定应用领域使用大头优先的数据结构，并且我们也留开放的不标准的大头优先或者双端系统的可能性。
我们不得不去固定字节顺序（包被存储在存储器中，不管存储器系统的字节顺序）去确保长度的编码位总是在半字地址序的最前面。这使得变长指令的长度能够快速地被取指部件通过只检查第一个 16-bit 指令包的最前面几位断定。一旦我们已经决定了固定采用一个小头优先的存储系统和指令包顺序，那么自然而然地会将长度的编码位放在指令格式的 LSB 的位置来避免解体操作码字段。

### 1.3 异常，自陷，和中断

我们使用术语异常（exception） 来指在运行时发生的不寻常的情况。我们使用术语自陷（trap）来指当被一个异常条件引起的事件发生在一个 RISC-V 的线程里的时候，同步地把控制权传输给管理员环境。我们使用术语中断（interrupt ）来指当由 RISC-V 线程之外的事件引起的事件发生的时候，异步地把控制权传输给管理员环境。

在接下去的章节中的指令叙述中，描述了在执行过程中，引起异常的情况。这样是否又如何被转换成自陷取决于执行环境，尽管预期是当发出异常信号的时候，大多数环境下将会采取精确的自陷（除了浮点异常，这在标准的浮点拓展中是不会导致自陷的）。

> 我们的“异常”和“自陷”的使用和在 IEEE-754 中的浮点标准相匹配。

![photo1][1]

图 1.1：RISC-V 指令长度编码格式   

![photo2][2]

图 1.2：从寄存器中存储 32-bit 指令到存储器中建议的代码顺序。在大头优先和小头优先的存储系统中都能正确地操作并且避免了当有变长指令集拓展被使用时，不对齐的访问。



  [1]: /master/image/photo1.jpg
  [2]: /master/image/photo2.jpg
